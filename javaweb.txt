1.tomcat下载：
	https://tomcat.apache.org/download-80.cgi
	下载zip文件

2.配置
	conf/tomcat-users.xml
	添加：
	<user username="admin" password="admin" roles="manager-gui,admin-gui"/>
	conf/web.xml
	添加：
	<init-param>
            <param-name>compilerSource</param-name>
            <param-value>1.8</param-value>
        </init-param>
        <init-param>
            <param-name>compilerTargetVM</param-name>
            <param-value>1.8</param-value>
        </init-param>
	conf/server.xml可以修改接口

3.运行
	./startup.sh
	如果出现startup.sh: command not found
        需要更改startup.sh权限
	sudo chmod 755 *.sh //需要在tomcat-xxx/bin/目录下执行
	执行成功访问http://localhost:8080/
	./shutdown.sh关闭tomcat

4.创建Maven
	groupId一般分为多个段，这里我只说两段，第一段为域，第二段为公司名称。域又分为org、com、cn等等许多。如：top.hellozwj
	artifactId设置为项目的名称;
	使用阿里maven：
	修改pom.xml:
		<repositories><!-- 代码库 -->
        		<repository>
          			<id>maven-ali</id>
            			<url>http://maven.aliyun.com/nexus/content/groups/public//</url>
            			<releases>
                			enabled>true</enabled>
            			</releases>
            			<snapshots>
                			<enabled>true</enabled>
                			<updatePolicy>always</updatePolicy>
                			<checksumPolicy>fail</checksumPolicy>
            			</snapshots>
        		</repository>
    		</repositories>
	如果想修改settings文件的话：settings.xml的默认路径就：个人目录/.m2/settings.xml
		Mac下在～/.m2/下,如果没有就自己创建
			内容：<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
      				xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      				xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                          	https://maven.apache.org/xsd/settings-1.0.0.xsd">
  				<localRepository/>
  				<interactiveMode/>
  				<usePluginRegistry/>
  				<offline/>
  				<pluginGroups/>
  				<servers/>
  				<mirrors/>
  				<proxies/>
  				<profiles/>
  				<activeProfiles/>
			</settings>
5.下载离线maven
http://maven.apache.org/download.cgi
Mac 下载-bin.tar.gz解压到zwj/applictions
在使用idea创建maven时，更改默认的maven,选择解压的目录就到apache-maven-3.5.4
同时settings也要改为apache-maven-3.5.4/conf/settings.xml
<mirrors>中添加
	<mirror>
        	<id>nexus-aliyun</id>
        	<mirrorOf>*</mirrorOf>
        	<name>Nexus aliyun</name>
        	<url>http://maven.aliyun.com/nexus/content/groups/public</url>
    	</mirror>

6.IDEA设置tomcat
	run->Edit Configurations
	点击：+,点击：tomcat server,点击：local
	然后配置tomcat，选择解压的tomcat目录
	如果出现错误：no artifacts configured：
	打开file->Project Structure,选择Aritfacts选项， 选择Web Application:Exploded,修改命名name,在右边avilable elements下选中要添加的项目，点击+，选择directory content,选择项目的目录.再次进入Edit Configration->Deployment，点击+号，即可看到Artifact选项了.(注意：Aritfact一定要是：xxx:war exploded)
	war模式：将WEB工程以包的形式上传到服务器 ；
	war exploded模式：直接把文件夹、jsp页面 、classes等等移到Tomcat 部署文件夹里面，进行加载部署，一般在开发的时候也是用这种方式。
	就可以运行项目了，但什么都没有浏览器会显示404

7.创建webapp
选择Maven项目时，勾选create from archetype,并选中org.apache.maven.archetypes:maven-archetype-webapp.
然后创建完项目后会加载很多依赖，会很慢，加载完后才会出现所有目录结构，不然只有pom.xml。
最后下载离线的Maven，在创建项目时更改为自己下载的maven解压后的目录，settings.xml也要更改为自己的settings.xml在maven目录的conf目录里。

8.创建的项目main下没有java目录
解决：   选择File->Project Structure
	选择Modules选项卡下面的Sources项，在main文件夹上右键，选择New Folder...并点击OK
	输入要创建的文件夹名称java，并点击OK继续
	在创建好的java文件夹上右键选择Sources项将该文件夹标记为源文件夹
	我们发现java文件夹已经由黄色变成了蓝色，我们点击OK按钮表示设置完成（蓝色就对了）
解决2:在main文件夹上右键,直接创建目录，即可。

9.Servlet should have a mapping
请添加<servlet-mapping>
    	<servlet-name>HelloWorld</servlet-name>
    	<url-pattern>/hello</url-pattern>
     </servlet-mapping>


10.创建断点
<servlet>下添加
<load-on-startup>1</load-on-startup>

11.@WebServlet(
        name = "hello",
        urlPatterns = {"/hello","/greeting"},
        loadOnStartup = 1
)可以代替web.xml的servlet的配置


12.javax.inject.jar：依赖注入非常方便的jar包.
用过Spring框架的我们都知道，每当生成依赖注入的时候，我们都必须生成相应类的set方法，而且要在set方法上面写上@Autowired，才能实现依赖注入.


13.scope=compile的情况（默认scope),也就是说这个项目在编译，测试，运行阶段都需要这个artifact对应的jar包在classpath中。
scope=provided的情况，则可以认为这个provided是目标容器已经provide这个artifact。换句话说，它只影响到编译，测试阶段。在编译测试阶段，我们需要这个artifact对应的jar包在classpath中，而在运行阶段，假定目标的容器（比如我们这里的liferay容器）已经提供了这个jar包，所以无需我们这个artifact对应的jar包了。

14.Artifact 是maven中的一个概念，表示某个module要如何打包。


15scope的分类
compile
默认就是compile，什么都不配置也就是意味着compile。compile表示被依赖项目需要参与当前项目的编译，当然后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去。
test
scope为test表示依赖项目仅仅参与测试相关的工作，包括测试代码的编译，执行。比较典型的如junit。
runntime
runntime表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过编译而已，说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。oracle jdbc驱动架包就是一个很好的例子，一般scope为runntime。另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。
provided
provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。
system
从参与度来说，也provided相同，不过被依赖项不会从maven仓库抓，而是从本地文件系统拿，一定需要配合systemPath属性使用。


16.RSS 简单信息聚合

17.SOAP(simple object access protocol)简单对象访问协议

18.ORM对象关系映射
面向对象编程语言

19.应用服务器有专门用于管理连接池的内建系统，可以改善应用程序中数据库连接的性能。对应管理这些连接的应用服务器，必须在应用服务器类加载器中而不是web应用类加载器中加载JDBC驱动。
在mysql官网下载mysql JDBC,拿到JAR文件,把它放到tomcat\lib下。修改tomcat\conf\context.xml
在<Context>里添加
<Resource
            name="jdbc/GZXS"
            type="javax.sql.DataSource"
            maxActive="100"
            maxIdle="30"
            maxWait="5000"
            username="root"
            password="123456"
            driverClassName="com.mysql.jdbc.Driver"
            url="jdbc:mysql://localhost:3306/GZXS?autoReconnect=true&amp;useSSl=false"
    />
//maxIdle连接池中最少空闲30个连接，maxWait连接池连接用完时新请求等待时间，name为Resource的名字,&amp;是&的转义符直接使用&会报错。
mysql-connector-java-bin.jar与mysql-connector-java.jar
使用上是没区别的一样的,都可以用,带-bin的文件里在编译的的时候里面多了几个编译用的校验文件而已.
数据源在tomcat /conf/content/xml与/conf/server.xml的区别
server.xml不可动态重新加载资源，要修改这个文件，就要重启才能重新加载。context.xml文件，tomcat一旦文件修改(时间戳改变)，就会重新加载这个文件，不需要重启服务器。

20.ubuntu 安装tomcat9
下载：apache-tomcat-9.0.11.tar.gz
解压到/usr/local
修改tomcat/bin下的startup.sh文件，在最后添加
export JAVA_HOME=/usr/local/java
export JRE_HOME=${JAVA_HOME}/jre
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib
export PATH=${JAVA_HOME}/bin:$PATH

启动tomcat
  ./bin/startup.sh
  curl localhost:8080
关闭tomcat
  ./bin/shuntdown.sh

21.SpringMVC 中 url-patter 与 @RequestMapping 的对应问题
利用 SpringMVC 响应前端发起的请求时，其完整 url 会按照 DispatcherServlet 指定的 url 格式进行匹配、修剪，去掉<url-pattern>指定的上下文部分，剩余部分 url'，再由注解 @RequestMapping 转到 Controller 特定的方法上，执行具体的处理。
前端请求的完整 url：
	http://localhost:8088/aaa/bbb/ccc?myParam=myValue
servlet 指定的 url 格式：
	<url-pattern>/aaa/*</url-pattern> <!-- *一定要加不然访问不了 -->
则 @RequestMapping 的正确配置为：
	@RequestMapping(value="/bbb/ccc")
	public String demoMethodSignature(String myParam) 
	

22.Spring项目
Controller层：负责具体业务模块流程的控制，即调用Service层的接口来控制业务流程。负责url映射（action）。
Dao层：负责数据持久化，与数据库进行联络的任务都封装在其中，Dao层的数据源以及相关的数据库连接参数都在Spring配置文件中进行配置。
Entity层：java对象，与数据库表一一对应，是其对应的实现类。即一个Entity就是对应表中的一条记录。
Service层：建立在DAO层之上，Controller层之下。调用Dao层的接口，为Controller层提供接口。负责业务模块的逻辑应用设计，首先设计接口，再设计其实现的类。
View层：表示层，负责前端jsp页面表示。

23.JDBC连接数据库java.sql.Connection
import java.sql.*;
//声明Connection对象
         Connection con;
         //驱动程序名
        String driver = "com.mysql.jdbc.Driver";
         //URL指向要访问的数据库名mydata
         String url = "jdbc:mysql://localhost:3306/sqltestdb";
         //MySQL配置时的用户名
         String user = "root";
        //MySQL配置时的密码
         String password = "123456";
             //加载驱动程序
             Class.forName(driver);
             //1.getConnection()方法，连接MySQL数据库！！
             con = DriverManager.getConnection(url,user,password);
	     Statement stat = conn.createStatement()创建一个Statement对象来将SQL语句发送到数据库
	    //要执行的SQL语句
             String sql = "select count(1) from VIEW_JLZDH_OB_DL_DAY";
	    //ResultSet类，用来存放获取的结果集！！
            ResultSet rs = statement.executeQuery(sql);
	    while (rs.next()){
                //输出结果
                System.out.println(rs.getString("count(1)"));
            }

24.mac IDEA try catch自动添加，option+command+t

25.preparedStatement与Statement
preparedStatement是预编译的，对批处理可以大大提高效率，Statement只执行一次性存取。preparedStatement用于执行带参数的预编译SQL, Statement执行不带参数的简单SQL。执行的对象较多时，preparedStatement会降低运行时间。企业更喜欢preparedStatement，因为它更安全，传递给preparedStatement的对象参数可以被强制进行类型转换。Statement每次执行一个SQL，都会对它进行解析和编译。preparedStatement和Statement都需要调用close函数关闭，不应等待对象自动关闭。

26.java:comp/env/
这是J2EE环境的定义，代表了当前J2EE应用的环境，使用这样的方式，必须设置当前应用环境到资源名的映射。

27.JDBC-DataSource(数据库连接池)
JDBC的数据库连接池使用javax.sql.DataSource来表示，它只是一个接口，该接口由应用服务器实现，或开源组织（DBCP,C3P0）.
DBCP:
需要两个依赖：commons-dbcp.jar，commons-pool.jar
Tomcat的连接池正是采用这个连接池实现的，可以和应用服务器整合使用，也可以由程序单独使用。
C3P0:
C3p0性能更胜一筹，hibernate推荐使用该连接池，c3p0连接池不仅可以自动清理不使用的connection，还可以自动清理statement和resultset.






